
// This is an autogenerated file from Firebase Studio.
'use server';

/**
 * @fileOverview A repair recommendation AI agent.
 *
 * - recommendRepairs - A function that recommends repairs for a single asset.
 * - recommendRepairsForAllAssets - A function that recommends repairs for a list of assets.
 * - RecommendRepairsInput - The input type for the recommendRepairs function.
 * - RecommendRepairsOutput - The return type for the recommendRepairs function.
 * - RecommendRepairsAllAssetsInput - The input type for the recommendRepairsForAllAssets function.
 * - RecommendRepairsAllAssetsOutput - The return type for the recommendRepairsForAllAssets function.
 */

import {ai} from '@/ai/genkit';
import {z} from 'genkit';

const RecommendRepairsInputSchema = z.object({
  conditionData: z.string().describe('The condition data of the asset.'),
  assetType: z.string().describe('The type of the asset.'),
  userDefinedRules: z.string().describe('The user-defined rules for repair recommendations.'),
});
export type RecommendRepairsInput = z.infer<typeof RecommendRepairsInputSchema>;

const RecommendRepairsOutputSchema = z.object({
  recommendations: z.string().describe('The recommended repairs or replacements.'),
  reasoning: z.string().describe('The reasoning behind the recommendations.'),
});
export type RecommendRepairsOutput = z.infer<typeof RecommendRepairsOutputSchema>;

const AssetSchema = z.object({
  assetId: z.string(),
  address: z.string(),
  yearInstalled: z.number(),
  material: z.enum(['Concrete', 'Polyethylene', 'Fibreglass']),
  setbackFromWaterSource: z.number(),
  setbackFromHouse: z.number(),
  tankBuryDepth: z.number(),
  openingSize: z.number(),
  aboveGroundCollarHeight: z.number(),
  septicSystemType: z.enum(['Cistern', 'Septic Tank']),
  assetSubType: z.enum(['Cistern', 'Pump Out', 'Mound', 'Septic Field', 'Other']),
  siteCondition: z.number(),
  coverCondition: z.number(),
  collarCondition: z.number(),
  interiorCondition: z.number(),
  overallCondition: z.number(),
  fieldNotes: z.string(),
});

const RepairPriceSchema = z.object({
    id: z.string(),
    repairType: z.string(),
    unitPrice: z.number(),
});

const RecommendRepairsAllAssetsInputSchema = z.object({
    assets: z.array(AssetSchema),
    repairPrices: z.array(RepairPriceSchema).describe("A list of available repair types and their unit prices."),
    userDefinedRules: z.string().describe('The user-defined rules for repair recommendations.'),
});

export type RecommendRepairsAllAssetsInput = z.infer<typeof RecommendRepairsAllAssetsInputSchema>;

const SingleAssetRecommendationSchema = z.object({
    assetId: z.string(),
    recommendation: z.string().describe('The recommended repair or replacement action. Should be a short summary.'),
    recommendedRepairType: z.string().describe("The specific repair type. This can be from the provided price list or a new one if appropriate. If no specific repair is applicable, return 'None'."),
    estimatedCost: z.number().describe("The estimated cost for the repair. If the repair type is not in the price list, return 0."),
    needsPrice: z.boolean().describe("Set to true if the recommended repair type does not have a price in the provided list, otherwise set to false."),
});

const RecommendRepairsAllAssetsOutputSchema = z.object({
    recommendations: z.array(SingleAssetRecommendationSchema),
});
export type RecommendRepairsAllAssetsOutput = z.infer<typeof RecommendRepairsAllAssetsOutputSchema>;


export async function recommendRepairs(input: RecommendRepairsInput): Promise<RecommendRepairsOutput> {
  return recommendRepairsFlow(input);
}

export async function recommendRepairsForAllAssets(input: RecommendRepairsAllAssetsInput): Promise<RecommendRepairsAllAssetsOutput> {
    return recommendRepairsForAllAssetsFlow(input);
}


const singleAssetPrompt = ai.definePrompt({
  name: 'recommendRepairsPrompt',
  input: {schema: RecommendRepairsInputSchema},
  output: {schema: RecommendRepairsOutputSchema},
  prompt: `You are an AI assistant that recommends repairs or replacements for assets based on their condition, type, and user-defined rules.\n\nCondition Data: {{{conditionData}}}\nAsset Type: {{{assetType}}}\nUser-Defined Rules: {{{userDefinedRules}}}\n\nBased on this information, provide specific repair or replacement recommendations and explain your reasoning. Return your answer in the format prescribed by the output schema.`,}
);

const recommendRepairsFlow = ai.defineFlow(
  {
    name: 'recommendRepairsFlow',
    inputSchema: RecommendRepairsInputSchema,
    outputSchema: RecommendRepairsOutputSchema,
  },
  async input => {
    const {output} = await singleAssetPrompt(input);
    return output!;
  }
);


const allAssetsPrompt = ai.definePrompt({
  name: 'recommendRepairsForAllAssetsPrompt',
  input: { schema: RecommendRepairsAllAssetsInputSchema },
  output: { schema: RecommendRepairsAllAssetsOutputSchema },
  prompt: `You are an AI assistant that recommends repairs or replacements for a list of assets based on their condition, type, and user-defined rules. Your most important task is to prioritize the 'fieldNotes'.

You MUST follow this logic:
1.  For each asset, first examine the 'fieldNotes'. This is the most critical piece of information.
2.  Identify keywords in the 'fieldNotes' describing a problem (e.g., "damaged lid", "cracked cover", "roots", "leaking").
3.  Search the 'repairPrices' list for a 'repairType' that directly addresses the problem described in the notes. For example, if notes say "cracked lid", you should look for a repair like "Lid Replacement" or "Cover Repair".
4.  If a matching repair is found in the 'repairPrices' list:
    - Set 'recommendation' to a short summary of that action (e.g., "Replace damaged lid").
    - Set 'recommendedRepairType' to the exact 'repairType' from the price list.
    - Set 'estimatedCost' to the corresponding 'unitPrice'.
    - Set 'needsPrice' to false.
5.  If the 'fieldNotes' describe a clear problem but you CANNOT find a matching repair in the 'repairPrices' list:
    - Set 'recommendation' to describe the needed repair (e.g., "Repair crack in tank").
    - Set 'recommendedRepairType' to a new, descriptive name (e.g., "Tank Crack Repair").
    - You MUST set 'estimatedCost' to 0.
    - You MUST set 'needsPrice' to true.
6.  If and only if the 'fieldNotes' indicate no problems, then you may consider the numerical condition scores. If scores are low (3 or less), recommend a general inspection.
7.  If the 'fieldNotes' are clear and condition scores are good, the correct output is "No action needed".

Available Repairs and Prices:
{{#each repairPrices}}
- {{repairType}}: \${{unitPrice}}
{{else}}
- No prices provided.
{{/each}}

User-Defined Rules: {{{userDefinedRules}}}

Assets to Analyze:
{{#each assets}}
- Asset ID: {{assetId}}
- Type: {{septicSystemType}}
- Sub-Type: {{assetSubType}}
- Year Installed: {{yearInstalled}}
- Material: {{material}}
- Site Condition: {{siteCondition}}/5
- Cover Condition: {{coverCondition}}/5
- Collar Condition: {{collarCondition}}/5
- Interior Condition: {{interiorCondition}}/5
- Overall Condition: {{overallCondition}}/5
- Field Notes: "{{fieldNotes}}"
{{/each}}

Return your answer as a list of recommendations, one for each asset ID, in the format prescribed by the output schema.
`,
});

const recommendRepairsForAllAssetsFlow = ai.defineFlow(
    {
        name: 'recommendRepairsForAllAssetsFlow',
        inputSchema: RecommendRepairsAllAssetsInputSchema,
        outputSchema: RecommendRepairsAllAssetsOutputSchema,
    },
    async (input) => {
        const { output } = await allAssetsPrompt(input);
        return output!;
    }
);
